import pandas as pd 
#for command line arguments
import argparse
#for reading files
import os
#parsing command line arguments
from datetime import datetime
#reading and writing files
import shutil
#matrix math
import numpy as np
#real-time server
import socketio
#concurrent networking 
import eventlet
#web server gateway interface
import eventlet.wsgi
#image manipulation
from PIL import Image
#web framework
from flask import Flask
#input output
from io import BytesIO
from sklearn.model_selection import train_test_split #to split out training and testing data 
#keras is a high level wrapper on top of tensorflow (machine learning library)
#The Sequential container is a linear stack of layers
from keras.models import Sequential
#popular optimization strategy that uses gradient descent 
from keras.optimizers import Adam
#to save our model periodically as checkpoints for loading later
from keras.callbacks import ModelCheckpoint
#what types of layers do we want our model to have?
from keras.layers import Lambda, Conv2D, MaxPooling2D, Dropout, Dense, Flatten
from keras.models import load_model
from glob import glob
from scipy.optimize import differential_evolution

import helper
import base64
import utils 
import pickle
import h5py
import tensorflow as tf
import scipy.misc
import scipy


#load the model generated by Udacity during the training mode
# during the training mode, Udacity generates .h5 files that encode different coordinates 
model = load_model('model-001.h5')


def distance(a, b):
	dist = np.linalg.norm(a-b)
	dist = np.array([[dist]], dtype=float)
	print(type(dist))
	return dist

def pred_dist (x, ishape):
	x = distance(image, image2)
	ishape = x.shape
	m = x.reshape(ishape)
	return m

def model_predict(x, ishape):
	# d = distance (x, image)
	x = x.astype(int)
	#print ('1', x)
	x = x.reshape(ishape)
	#print (x)
	pred = model.predict(x, batch_size=1)
	#print('pred:', type(pred))
	#print(pred)
	#print(type(np.degrees(abs(pred))))
	return np.degrees(abs(pred))

def NewImg (image):
	im = Image.new('RGB', (320, 160))
	im.putdata(image.tolist())
	im.save("image1.jpg")
	return image
	
image = Image.open ('left_2018_07_06_16_20_13_552.jpg')  # open an image from the IMG folder created after training mode 
image = np.asarray(image)       # numpy array 
image = utils.preprocess(image) # apply the preprocessing
image = np.array([image])       # create a 4D array

#steering angle
steering_angle = np.degrees(float(model.predict(image, batch_size=1)))
print ("Initial angle=%f"%steering_angle) 


ishape = image.shape
# create 1D array by reshaping 
image = image.reshape(image.size, )

#open a second image and reshape it in a 1D array 
image2 = Image.open ('left_2018_06_29_14_49_47_526.jpg')
image2 = np.asarray(image2)
image2 = utils.preprocess (image2)
image2 = np.array([image2])
image2 = image2.reshape(image2.size, )

#scipy.optimize.differential_evolution(func, bounds, args=(), strategy='best1bin', maxiter=1000, popsize=15, tol=0.01, mutation=(0.5, 1), recombination=0.7, 
#                                      seed=None, callback=None, disp=False, polish=True, init='latinhypercube', atol=0)[source]
# Finds the global minimum of a multivariate function.
# Differential Evolution (DE) is stochastic in nature (does not use gradient methods) to find the minimium, and can search large areas of candidate space, 
# but often requires larger numbers of function evaluations than conventional gradient based techniques. (https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.differential_evolution.html)
# DE is used to minimize the distance between the two images.

# bounds = Bounds for variables, (min, max) pairs for each element in x, defining the lower and upper bounds for the optimizing argument of func
# add pixel values for every iteration p in pix 
bounds = []
for p in image:
	bounds.append((0, 255))

b = NewImg(image)
print (b)
# args = Any additional fixed parameters needed to completely specify the objective function.
# maxiter = The maximum number of generations over which the entire population is evolved 
# init = Specify which type of population initialization is performed. It could be 'latinhypercube', 'random' or an array specifying the initial population
#initial population = list
pop = []
for i in range(20):
	newImg = np.array(image)
	for p in range(newImg.size):
		if np.random.random() < 0.1:
			newImg[p] = int(np.random.random() * 255)
	pop.append(newImg)

# disp = status message
# polish = If True (default), then scipy.optimize.minimize with the L-BFGS-B method is used to polish the best population member at the end, 
#          which can improve the minimization slightly.

# res = The optimization result represented as a OptimizeResult object. Important attributes are: x the solution array, success a Boolean flag indicating if 
#       he optimizer exited successfully and message which describes the cause of the termination. See OptimizeResult for a description of other attributes. 
#       If polish was employed, and a lower minimum was obtained by the polishing, then OptimizeResult also contains the jac attribute.
print("starting DE")
steering_angle = differential_evolution(model_predict, bounds, args=(ishape,), maxiter=100, init=pop, disp=True,polish=False)
print(steering_angle)
print("DONE")

#get the distance
pix = distance (image, image2)
ishape1 = pix.shape
dist = pred_dist(pix, ishape1)
print (dist)

#save the modified image
a = NewImg(image)






